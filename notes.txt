
python farkle


game:
  state: {
    players: [p1, p2, p3],
    score: [2000, 1250, 1800],
    current_player: 0,
    prev_score: 0,
    prev_available_dice: 6
    game_end: 10000
  }

  def playgame():
    while gameend is false:
      playnextturn()
      update(score, player)
    calculate_ranking()

  def playnextturn():
    turnend = False
    select next_player
    turn_score = 0
    available_dice = 6
    while turnend is False:
      their_play = request_turn_from_player(state, possible_moves)
      if their_play==0:
        turnend = True
        update_state(turn_score)
      update_turn_score(their_play)
      roll = roll_dice(their_play)
      if farkle(roll):
        turn_score = 0
        update_state(turn_score)
        break

def playnextturn():
  send overall state:
    all players scores
    current players id (so it can find score of next player too)
    game-ending score

  ask for starting preference:
    send previous turn score and available dice
    if response is 1, continue from previous player
    if response is 0, start fresh

  roll = do the first roll
  turnscore = 0

  while True:
    if farkle(roll):
      turnscore = 0
      break
    else:
      send player roll results
      move = ask_player_for_move()
      if move is array of zeros: #indicates turn end
        turnscore += calculate optimal score from roll
        break
      turnscore += get_score(move, roll)
      roll = roll_dice(number of unrolled dice, or 6 if there are no unrolled dice)

  update score/state


asking players is a function
ask(data,player):
  returns answer

for each player:
from playername import player

function player.recieve_state()
  args: gamestate at beginning of their turn
  returns: nothing

function player.turn_start()
  args: prev score, dice available
  return: 1 or 0 (1=roll from prev turn, 0=start fresh)

function player.decide_move()
  args: current turn score, array for previous roll,
  return: array same size as the roll array, filled with 1s or 0s.
          all 0s = end turn
          otherwise, a 1=keep die and 0=reroll this die

  






  ask for


calculate last round:
  start counter at 1
  each turn, counter++
  when last round, set counter to -(number_of_players)
  when counter==0, game is over


Class Player:

  def __init__(self, player_num):
    self.player_num = player_num

  play_turn(self, score, prev_turn):
    turn_score = 0

    # ...

    return [turn_score, remaining_dice]

Class Human:

  def __init__(self, player_num):
    self.player_num = player_num

  play_turn(self, score, prev_turn):
    turn_score = 0
    stop = True

    while stop==False:
      print("Your score is %s and turn is %s." % (score[self.player_num]))
      #stop = decide_move()

    print("Your score is %s and turn is %s." % (score[self.player_num]))
    addition = input("what score increment?")
    turn_score += addition
    return [turn_score, 0]





Class game:

  static END_SCORE = 10000
  static NUM_PLAYERS = 4

  def __init__():
    players = connect_players() # array of players, in turn order
    score = [] p0 score is score[0], p1 score is score[1], etc.
    prev_turn = [] #array: [score, number of dice left]
    cur_player = 0
    game_over = False
    last_round = NUM_PLAYERS
    play_game()

  def connect_players(self):
    players = []
    for i in range NUM_PLAYERS:
      players[i] = new Player(i)
    return players

  def play_game(self):
    while game_over==False:
      recent_score = play_turn(players[cur_player])
      #check endgame:
      if recent_score > END_SCORE:
        game_over = True
        while last_round > 0:
          play_turn(players[cur_player])
          last_round -= 1

  def play_turn(self, player):
    id = player.player_num
    result = player.play_turn(self.score, self.prev_turn)
    self.score[id] += result[0]
    self.prev_turn = result[1]
    self.cur_player = (self.cur_player + 1) % NUM_PLAYERS
    return self.score[id]
